{
  "version": 3,
  "sources": ["../../nip13.ts", "../../utils.ts"],
  "sourcesContent": ["import { bytesToHex } from '@noble/hashes/utils.js'\nimport { type UnsignedEvent, type Event } from './pure.ts'\nimport { sha256 } from '@noble/hashes/sha2.js'\n\nimport { utf8Encoder } from './utils.ts'\n\n/** Get POW difficulty from a Nostr hex ID. */\nexport function getPow(hex: string): number {\n  let count = 0\n\n  for (let i = 0; i < 64; i += 8) {\n    const nibble = parseInt(hex.substring(i, i + 8), 16)\n    if (nibble === 0) {\n      count += 32\n    } else {\n      count += Math.clz32(nibble)\n      break\n    }\n  }\n\n  return count\n}\n\n/** Get POW difficulty directly from a Uint8Array hash. */\nfunction getPowFromBytes(hash: Uint8Array): number {\n  let count = 0\n\n  for (let i = 0; i < hash.length; i++) {\n    const byte = hash[i]\n    if (byte === 0) {\n      count += 8\n    } else {\n      count += Math.clz32(byte) - 24\n      break\n    }\n  }\n\n  return count\n}\n\n/**\n * Mine an event with the desired POW. This function mutates the event.\n * Note that this operation is synchronous and should be run in a worker context to avoid blocking the main thread.\n */\nexport function minePow(unsigned: UnsignedEvent, difficulty: number): Omit<Event, 'sig'> {\n  let count = 0\n\n  const event = unsigned as Omit<Event, 'sig'>\n  const tag = ['nonce', count.toString(), difficulty.toString()]\n\n  event.tags.push(tag)\n\n  while (true) {\n    const now = Math.floor(new Date().getTime() / 1000)\n\n    if (now !== event.created_at) {\n      count = 0\n      event.created_at = now\n    }\n\n    tag[1] = (++count).toString()\n\n    const hash = sha256(\n      utf8Encoder.encode(JSON.stringify([0, event.pubkey, event.created_at, event.kind, event.tags, event.content])),\n    )\n\n    if (getPowFromBytes(hash) >= difficulty) {\n      event.id = bytesToHex(hash)\n      break\n    }\n  }\n\n  return event\n}\n", "import type { NostrEvent } from './core.ts'\n\nexport const utf8Decoder: TextDecoder = new TextDecoder('utf-8')\nexport const utf8Encoder: TextEncoder = new TextEncoder()\n\nexport { bytesToHex, hexToBytes } from '@noble/hashes/utils.js'\n\nexport function normalizeURL(url: string): string {\n  try {\n    if (url.indexOf('://') === -1) url = 'wss://' + url\n    let p = new URL(url)\n    if (p.protocol === 'http:') p.protocol = 'ws:'\n    else if (p.protocol === 'https:') p.protocol = 'wss:'\n    p.pathname = p.pathname.replace(/\\/+/g, '/')\n    if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n    if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n    p.searchParams.sort()\n    p.hash = ''\n    return p.toString()\n  } catch (e) {\n    throw new Error(`Invalid URL: ${url}`)\n  }\n}\n\nexport function insertEventIntoDescendingList(sortedArray: NostrEvent[], event: NostrEvent): NostrEvent[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return b.created_at - event.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: NostrEvent[], event: NostrEvent): NostrEvent[] {\n  const [idx, found] = binarySearch(sortedArray, b => {\n    if (event.id === b.id) return 0\n    if (event.created_at === b.created_at) return -1\n    return event.created_at - b.created_at\n  })\n  if (!found) {\n    sortedArray.splice(idx, 0, event)\n  }\n  return sortedArray\n}\n\nexport function binarySearch<T>(arr: T[], compare: (b: T) => number): [number, boolean] {\n  let start = 0\n  let end = arr.length - 1\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2)\n    const cmp = compare(arr[mid])\n\n    if (cmp === 0) {\n      return [mid, true]\n    }\n\n    if (cmp < 0) {\n      end = mid - 1\n    } else {\n      start = mid + 1\n    }\n  }\n\n  return [start, false]\n}\n\nexport function mergeReverseSortedLists(list1: NostrEvent[], list2: NostrEvent[]): NostrEvent[] {\n  const result: NostrEvent[] = new Array(list1.length + list2.length)\n  result.length = 0\n  let i1 = 0\n  let i2 = 0\n  let sameTimestampIds: string[] = []\n\n  while (i1 < list1.length && i2 < list2.length) {\n    let next: NostrEvent\n    if (list1[i1]?.created_at > list2[i2]?.created_at) {\n      next = list1[i1]\n      i1++\n    } else {\n      next = list2[i2]\n      i2++\n    }\n\n    if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {\n      if (sameTimestampIds.includes(next.id)) continue\n    } else {\n      sameTimestampIds.length = 0\n    }\n\n    result.push(next)\n    sameTimestampIds.push(next.id)\n  }\n\n  while (i1 < list1.length) {\n    const next = list1[i1]\n    i1++\n\n    if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {\n      if (sameTimestampIds.includes(next.id)) continue\n    } else {\n      sameTimestampIds.length = 0\n    }\n    result.push(next)\n    sameTimestampIds.push(next.id)\n  }\n\n  while (i2 < list2.length) {\n    const next = list2[i2]\n    i2++\n\n    if (result.length > 0 && result[result.length - 1].created_at === next.created_at) {\n      if (sameTimestampIds.includes(next.id)) continue\n    } else {\n      sameTimestampIds.length = 0\n    }\n    result.push(next)\n    sameTimestampIds.push(next.id)\n  }\n\n  return result\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,gBAA2B;AAE3B,kBAAuB;;;ACGvB,mBAAuC;AAHhC,IAAM,cAA2B,IAAI,YAAY,OAAO;AACxD,IAAM,cAA2B,IAAI,YAAY;;;ADIjD,SAAS,OAAO,KAAqB;AAC1C,MAAI,QAAQ;AAEZ,WAAS,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG;AAC9B,UAAM,SAAS,SAAS,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE;AACnD,QAAI,WAAW,GAAG;AAChB,eAAS;AAAA,IACX,OAAO;AACL,eAAS,KAAK,MAAM,MAAM;AAC1B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAGA,SAAS,gBAAgB,MAA0B;AACjD,MAAI,QAAQ;AAEZ,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,OAAO,KAAK;AAClB,QAAI,SAAS,GAAG;AACd,eAAS;AAAA,IACX,OAAO;AACL,eAAS,KAAK,MAAM,IAAI,IAAI;AAC5B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAMO,SAAS,QAAQ,UAAyB,YAAwC;AACvF,MAAI,QAAQ;AAEZ,QAAM,QAAQ;AACd,QAAM,MAAM,CAAC,SAAS,MAAM,SAAS,GAAG,WAAW,SAAS,CAAC;AAE7D,QAAM,KAAK,KAAK,GAAG;AAEnB,SAAO,MAAM;AACX,UAAM,MAAM,KAAK,MAAM,IAAI,KAAK,EAAE,QAAQ,IAAI,GAAI;AAElD,QAAI,QAAQ,MAAM,YAAY;AAC5B,cAAQ;AACR,YAAM,aAAa;AAAA,IACrB;AAEA,QAAI,MAAM,EAAE,OAAO,SAAS;AAE5B,UAAM,WAAO;AAAA,MACX,YAAY,OAAO,KAAK,UAAU,CAAC,GAAG,MAAM,QAAQ,MAAM,YAAY,MAAM,MAAM,MAAM,MAAM,MAAM,OAAO,CAAC,CAAC;AAAA,IAC/G;AAEA,QAAI,gBAAgB,IAAI,KAAK,YAAY;AACvC,YAAM,SAAK,0BAAW,IAAI;AAC1B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": ["import_utils"]
}
